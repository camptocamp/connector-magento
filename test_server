#!/usr/bin/env python
"""
Copied from
https://github.com/OCA/maintainer-quality-tools/blob/master/travis/test_server

Adapted to run with this project.

Some effort may be done to make one unique setup working on our instances.

"""

from __future__ import print_function

import re
import os
import subprocess

RED = "\033[1;31m"
GREEN = "\033[1;32m"
CLEAR = "\033[0;m"
fail_msg = RED + "FAIL" + CLEAR
success_msg = GREEN + "Success" + CLEAR


def is_module(path):
    if not os.path.isdir(path):
        return False
    manifs = ['__openerp__.py', '__terp__.py', '__init__.py']
    files = os.listdir(path)
    filtered = [x for x in files if x in manifs]
    res = len(filtered) == 2 and '__init__.py' in filtered
    return res


def get_modules(path):
    # Avoid empty basename when path ends with slash
    if not os.path.basename(path):
        path = os.path.dirname(path)
    res = []
    if os.path.isdir(path) and not os.path.basename(path)[0] == '.':
        res = [x for x in os.listdir(path)
               if is_module(os.path.join(path, x))]
    return res


def has_test_errors(fname, dbname, check_loaded=True):
    """
    Check a list of log lines for test errors.
    Extension point to detect false positives.
    """
    # Rules defining checks to perform
    # this can be
    # - a string which will be checked in a simple substring match
    # - a regex object that will be matched against the whole message
    # - a callable that receives a dictionary of the form
    #     {
    #         'loglevel': ...,
    #         'message': ....,
    #     }
    ERRORS_IGNORE = [
        'Mail delivery failed',
        'failed sending mail',
        ]
    ERRORS_REPORT = [
        lambda x: x['loglevel'] == 'CRITICAL',
        'At least one test failed',
        'no access rules, consider adding one',
        'invalid module names, ignored',
        ]
    ERRORS_REPORT.append(
        lambda x: x['loglevel'] == 'ERROR')

    def make_pattern_list_callable(pattern_list):
        for i in range(len(pattern_list)):
            if isinstance(pattern_list[i], basestring):
                regex = re.compile(pattern_list[i])
                pattern_list[i] = lambda x: regex.match(x['message'])
            elif hasattr(pattern_list[i], 'match'):
                regex = pattern_list[i]
                pattern_list[i] = lambda x: regex.match(x['message'])

    make_pattern_list_callable(ERRORS_IGNORE)
    make_pattern_list_callable(ERRORS_REPORT)

    print("-"*10)
    # Read log file removing ASCII color escapes:
    # http://serverfault.com/questions/71285
    color_regex = re.compile(r'\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]')
    log_start_regex = re.compile(
        r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} \d+ (?P<loglevel>\w+) '
        '(?P<db>(%s)|([?])) (?P<logger>\S+): (?P<message>.*)$' % dbname)
    log_records = []
    last_log_record = dict.fromkeys(log_start_regex.groupindex.keys())
    with open(fname) as log:
        for line in log:
            line = color_regex.sub('', line)
            match = log_start_regex.match(line)
            if match:
                last_log_record = match.groupdict()
                log_records.append(last_log_record)
            else:
                last_log_record['message'] = '%s\n%s' % (
                    last_log_record['message'], line.rstrip('\n')
                )
    errors = []
    for log_record in log_records:
        ignore = False
        for ignore_pattern in ERRORS_IGNORE:
            if ignore_pattern(log_record):
                ignore = True
                break
        if ignore:
            break
        for report_pattern in ERRORS_REPORT:
            if report_pattern(log_record):
                errors.append(log_record)
                break

    if check_loaded:
        if not [r for r in log_records if 'Modules loaded.' == r['message']]:
            errors.append({'message': "Modules loaded message not found."})

    if errors:
        for e in errors:
            print(e['message'])
        print("-"*10)
    return len(errors)


def parse_list(comma_sep_list):
    return [x.strip() for x in comma_sep_list.split(',')]


def main():
    travis_home = os.path.dirname(os.path.realpath(__file__))
    specific_parts = os.environ.get("SPECIFIC_PARTS",
                                    "specific-parts/specific-addons")
    odoo_unittest = os.environ.get("UNIT_TEST")
    odoo_exclude = os.environ.get("EXCLUDE")
    odoo_include = os.environ.get("INCLUDE")
    database = os.environ.get("DB_NAME", 'odoo')
    db_user = os.environ.get("DB_USER")
    db_pass = os.environ.get("DB_PASS")
    options = os.environ.get("OPTIONS", "").split()
    install_options = os.environ.get("INSTALL_OPTIONS", "").split()
    expected_errors = int(os.environ.get("SERVER_EXPECTED_ERRORS", "0"))
    test_loghandler = None
    options += ["--test-enable"]
    test_loglevel = 'test'
    python_path = os.path.join(travis_home, 'sandbox', 'bin', 'python')
    server_path = os.path.join(travis_home, 'bin', 'start_openerp')

    if odoo_include:
        tested_addons_list = parse_list(odoo_include)
    else:
        tested_addons_list = get_modules(specific_parts)

    if odoo_exclude:
        exclude_list = parse_list(odoo_exclude)
        tested_addons_list = [x for x in tested_addons_list
                              if x not in exclude_list]
    tested_addons = ','.join(tested_addons_list)

    if not tested_addons:
        print("WARNING!\nNothing to test- exiting early.")
        return 0
    else:
        print("Modules to test: %s" % tested_addons)

    # setup the base module without running the tests
    print("\nCreating test instance:")
    dbtemplate = "openerp_template"
    subprocess.check_call(["psql",
                           '-c',
                           'CREATE USER %s WITH PASSWORD \'%s\' CREATEDB;' %
                           (db_user, db_pass),
                           'postgres'])
    subprocess.check_call(["createdb", dbtemplate])

    preinstall_modules = 'mail' if odoo_unittest else tested_addons
    cmd_odoo = [python_path,
                server_path,
                "-d", dbtemplate,
                "--log-level=warn",
                "--stop-after-init",
                "--init", preinstall_modules,
                ] + install_options
    print(" ".join(cmd_odoo))
    subprocess.check_call(cmd_odoo)

    # Running tests
    if odoo_unittest:
        to_test_list = tested_addons_list
        cmd_odoo_install = [python_path,
                            server_path,
                            "-d", database,
                            "--stop-after-init",
                            "--log-level=warn",
                            ] + install_options + ["--init", None]

        cmd_odoo_test = [python_path,
                         server_path,
                         "-d", database,
                         "--stop-after-init",
                         "--log-level", test_loglevel,
                         ]
        if test_loghandler is not None:
            cmd_odoo_test += ['--log-handler', test_loghandler]
        cmd_odoo_test += options + ["--update", None]

        commands = ((cmd_odoo_install, False),
                    (cmd_odoo_test, True),
                    )
    else:
        to_test_list = [tested_addons]
        cmd_odoo_test = [python_path,
                         server_path,
                         "-d", database,
                         "--stop-after-init",
                         "--log-level", test_loglevel,
                         ]
        if test_loghandler is not None:
            cmd_odoo_test += ['--log-handler', test_loghandler]
        cmd_odoo_test += options + ["--init", None]
        commands = ((cmd_odoo_test, True),
                    )
    all_errors = []
    counted_errors = 0
    for to_test in to_test_list:
        print("\nTesting %s:" % to_test)
        subprocess.call(["createdb", "-T", dbtemplate, database])
        for command, check_loaded in commands:
            command[-1] = to_test
            print(' '.join(command))
            # Run test command; unbuffer keeps output colors
            command_call = ["unbuffer"] + command
            pipe = subprocess.Popen(command_call,
                                    stderr=subprocess.STDOUT,
                                    stdout=subprocess.PIPE)
            with open('stdout.log', 'w') as stdout:
                for line in pipe.stdout:
                    stdout.write(line)
                    print(line.strip())
            returncode = pipe.wait()
            # Find errors, except from failed mails
            errors = has_test_errors("stdout.log", database, check_loaded)
            if errors:
                counted_errors += errors
                all_errors.append(to_test)
                print(fail_msg, "Found %d lines with errors" % errors)
            if returncode != 0:
                all_errors.append(to_test)
                print(fail_msg, "Command exited with code %s" % returncode)
        subprocess.call(["dropdb", database])

    print('Module test summary')
    for to_test in to_test_list:
        if to_test in all_errors:
            print(fail_msg, to_test)
        else:
            print(success_msg, to_test)
    if expected_errors and counted_errors != expected_errors:
        print("Expected %d errors, found %d!"
              % (expected_errors, counted_errors))
        return 1
    elif counted_errors != expected_errors:
        return 1
    # if we get here, all is OK
    return 0

if __name__ == '__main__':
    exit(main())
